# The Actuary July 2012 Puzzle 508 - Square numbers

## Square
Unfortunately the puzzle seems to not be downloadable to grab the actual puzzle.

Initial thoughts lead to the following rules (many of them):

size_of_square_element <- list(
 c("a", "b", "c"),
 c("a", "b", "d", "e"),
 c("a", "b", "d", "e"), 
 c("a", "f", "g", "h", "e"), 
 c("a", "f", "g", "i", "j"), 
 c("k", "l", "m", "n", "g", "h", "e"), 
 c("k", "l", "m", "n", "g", "i", "j"), 
 c("k", "l", "q", "p", "j"), 
 c("k", "l", "m", "o", "p", "j"), 
 c("k", "l", "q", "p", "j"), 
 c("k", "l", "q", "r"), 
 c("k", "s", "t", "r"), 
 c("u", "t", "r"), 
 c("a", "k", "u"), 
 c("a", "l", "s", "u"), 
 c("a", "l", "t"), 
 c("b", "f", "m", "q", "t"), 
 c("b", "f", "n", "o", "q", "t"), 
 c("b", "f", "n", "p", "r"), 
 c("b", "g", "o", "q", "t"), 
 c("b", "g", "p", "r"), 
 c("b", "h", "i", "p", "r"), 
 c("b", "h", "j", "r"), 
 c("b", "h", "i", "o", "q", "t"), 
 c("c", "d", "h", "i", "o", "q", "t"), 
 c("c", "d", "h", "i", "p", "r"), 
 c("c", "d", "h", "j", "r"), 
 c("c", "e", "i", "o", "q", "t"), 
 c("c", "e", "i", "p", "r"), 
 c("c", "e", "j", "r")
)

# getting other relations:

first  <- c("a", "b", "c")
second <- c("a", "b", "d", "e")

# can derive from this that a = size_of_square_element - (b + c)

first_value_of_a = first[first != "a"]
list(
  a = list(
    first[first != "a"])
	
formulas_list <- lapply(size_of_square_element, FUN = function(square_total_element) {
  formula_vector = c(rep(1, length(square_total_element)), -1)
  names(formula_vector) <- c(square_total_element, "max_size")
  return(formula_vector)
})

formulas <- as.data.frame(lapply(1:22, FUN = function(x) character(0)))
names(formulas) <- c(letters[1:21], "max_size")

zero_formula <- rep(0, 22)
names(zero_formula) <-  names(formulas)

full_formulas_list <- lapply(formulas_list, FUN = function(the_formula) {
  a <- zero_formula
  a[names(the_formula)] <- the_formula
  return(a)
})

formulas <- data.frame(do.call("rbind", full_formulas_list))

custom_formula <- zero_formula
custom_formula["max_size"] 
formulas <- rbind(formulas, 

fmatrix <- formulas[as.character(letters[1:21])]
solve(fmatrix[2:22, 1:21], rep(10, 21))

dim(formulas)
solve(formulas[:22, 1:22])
colSums(formulas)
rowSums(formulas)

#sum(all^2) = size_of_square^2





Many simultaneous equations:


```{r}

```

## starting again with new logic:

# first pick a value for A
a <- 50

# now reduce all options others can be:

# b is smaller than b and larger than at least 


# definite order of size:

attr(a_properties, "larger_elements") <- c()
attr(a, "larger_elements") <- c()



letter_properties <- lapply(letters[1:21], FUN = function(x) list(smaller_elements = c()))
names(letter_properties) <- letters[1:21]

letter_properties[["a"]][["smaller_elements"]] <- letters[2:21]
letter_properties[["r"]][["smaller_elements"]] <- c(letters[2:17], letters[19:21])
letter_properties[["t"]][["smaller_elements"]] <- c(letters[2:17], "s", "u")
letter_properties[["b"]][["smaller_elements"]] <- c(letters[3:17], "s", "u")
letter_properties[["u"]][["smaller_elements"]] <- c(letters[3:17], "s")
letter_properties[["c"]][["smaller_elements"]] <- c("d", "e", "h", "i", "j", "l")
letter_properties[["d"]][["smaller_elements"]] <- c("i", "o")
letter_properties[["e"]][["smaller_elements"]] <- c("d", "h", "f", "g", "p")
letter_properties[["f"]][["smaller_elements"]] <- c("m", "n", "h")
letter_properties[["g"]][["smaller_elements"]] <- c("f", "h", "i", "n", "q")
letter_properties[["h"]][["smaller_elements"]] <- c("d", "i", "n", "o", "s", "m")
letter_properties[["i"]][["smaller_elements"]] <- c("n", "s")
letter_properties[["j"]][["smaller_elements"]] <- c("i", "p", "e")
letter_properties[["k"]][["smaller_elements"]] <- c("l", "s", "q", "m", "n", "o", "p", "c")
letter_properties[["l"]][["smaller_elements"]] <- c("s", "m", "n", "o", "p", "q", "e", "j")
letter_properties[["m"]][["smaller_elements"]] <- c("n", "o", "d", "s")
letter_properties[["n"]][["smaller_elements"]] <- c()
letter_properties[["o"]][["smaller_elements"]] <- c("i", "s", "n")
letter_properties[["p"]][["smaller_elements"]] <- c("m", "n", "o", "q", "h", "d", "f", "s", "i", "g")
letter_properties[["q"]][["smaller_elements"]] <- c("m", "n", "o", "h", "f")
letter_properties[["s"]][["smaller_elements"]] <- c("n")

smallers <- function(letter) {
  return(letter_properties[[letter]]$smaller_elements)
}

example_letter <- "b"
first_smaller_letters <- letter_properties[[example_letter]]$smaller_elements
new_smaller_letters <- sort(unique(c(first_smaller_letters, unlist(lapply(first_smaller_letters, smallers)))))
newer_smaller_letters <- sort(unique(c(new_smaller_letters, unlist(lapply(first_smaller_letters, smallers)))))

smaller_letters <- letter_properties[[example_letter]]$smaller_elements

full_smaller_letters <- function(letter) {
  new_smallers <- sort(smallers(letter))
  newer_smallers <- "12345678"
  
  while(!identical(new_smallers, newer_smallers)) {
    new_smallers <- sort(unique(c(new_smallers, unlist(lapply(new_smallers, smallers)))))
    newer_smallers <- sort(unique(c(new_smallers, unlist(lapply(new_smallers, smallers)))))
  }
  
  return(newer_smallers)
}
 
full_smaller_letters("a")

all_letters <- letters[1:21]
names(all_letters) <- all_letters

lapply(all_letters, FUN = function(letter) {
  letter_properties[[letter]][["smaller_elements"]] <<- full_smaller_letters(letter)
  })

letter_properties[order(unlist(lapply(letter_properties, FUN = function(x) length(x$smaller_elements))))]
length(unique(sapply(letter_properties, FUN = function(letter) length(letter$smaller_elements))))




largers <- function(letter) {
  names(letter_properties)[unlist(lapply(letter_properties, FUN = function(letter_prop) letter %in% letter_prop[["smaller_elements"]]))]
}
largers("a")
largers("r")
largers("s")
smallers("a")

  
# pick a starting value:
max_value <- 50
all_possible_values <- lapply(all_letters, FUN = function(x) 1:max_value)
#names(all_possible_values) <- all_letters

reduced_possible_values <- function(letter, possible_values = all_possible_values) {
  letter_possibles <- possible_values[[letter]]
  letter_smallers <- smallers(letter)
  letter_largers <- largers(letter)

  smallest_larger <- min(unlist(lapply(letter_largers, FUN = function(x) max(possible_values[[x]]))))
  largest_smaller <- max(unlist(lapply(letter_smallers, FUN = function(x) min(possible_values[[x]]))))
  
  letter_possibles <- letter_possibles[letter_possibles < smallest_larger]
  letter_possibles <- letter_possibles[letter_possibles > largest_smaller]
  return(letter_possibles)
}

all_possible_values[["n"]]
reduced_possible_values("n")
reduced_possible_values("r")

for(i in 1:100) all_possible_values <- lapply(all_letters, reduced_possible_values)

reduce_possibilities <- function(values, the_letters = all_letters, times = 21) {
  for(i in 1:times) values <- lapply(the_letters, reduced_possible_values, values)
  return(values)
}

all_possible_values <- reduce_possibilities(all_possible_values)

all_possible_values[["a"]]

potential_possible_values <- all_possible_values

i <- 2
potential_possible_values[["a"]] <- potential_possible_values[["a"]][i]

for(i in 1:100) potential_possible_values <- lapply(all_letters, reduced_possible_values, potential_possible_values)

#set value for a:

#set value for b:
#set value for c:
#set value for d:
#set value for e:
#set value for f:
#set value for g:
#set value for h:
#set value for i:
#set value for j:
#set value for k:
#set value for l:
#set value for m:
#set value for n:
#set value for o:
#set value for p:
#set value for q:
#set value for r:
#set value for s:
#set value for t:
#set value for u (given all others)
value_possible(u = 10, other_possible_values = c(a = 10, b = 12))

value_possible <- function(..., other_possible_values = c()) {
  
}

all_possible_values 

working_combinations <- list()
possible_values <- all_possible_values
 

letters_possible <- function(possible_values) {
  # needs to be recursive:
  next_possible_values <- possible_values
  non_length_1 <- unlist(lapply(possible_values, FUN = function(x) length(x) > 1))
  if(sum(non_length_1) != 0) {
    first_non_length_1 <- names(non_length_1[non_length_1][1])
    
    next_possible_values[first_non_length_1] <- next_possible_values[[first_non_length_1]][1]
	return(letters_possible(next_possible_values))
  } else {
    for(i in 1:50) next_possible_values <- lapply(all_letters, reduced_possible_values, next_possible_values)
	if(any(lapply(next_possible_values, length) == 0)) return(FALSE)
    browser()
	if(!conforms_to_max_sums(next_possible_values)) {
	  remove_possibility(next_possible_values, "all_possible_values") 
	  return(FALSE)}
	return(TRUE)
  }
}


conforms_to_max_sums <- function(number_set) {
  number_set <- unlist(number_set)
  sums <- unlist(lapply(size_of_square_element, FUN = function(max_set) sum(number_set[max_set])))
  return(length(unique(sums)) == 1)
}

# should do:

# pick the first value available for this letter
# go to the next letter, try first available
# go to next letter, if no first letter, then it failed.

letters_possible(all_possible_values)

number_set <- 1:21
names(number_set) <- letters[1:21]


sum(number_set[size_of_square_element[[1]]])
sum(number_set[size_of_square_element[[2]]])


is_possible("a", options_for_a)
  > is_possible("b", options_for_b)
  > is_possible("b", "first b")
   > is_possible("c", first_c)
     > FALSE
   > is_possible("c",

   
is_possible(all_options)
  > is_possible(a = first_a, all_other_options)
    > is_possible(a = first_a, b = first_b, all_other_options)
      > is_possible(a = first_a, b = first_b, c = first_c)
	    > FALSE
      > is_possible(a = first_a, b = first_b, c = next_c)
	    > FALSE
      > is_possible(a = first_a, b = first_b, c = next_c)
	    > FALSE
	> FALSE
  > FALSE
  

	
possible_values <- all_possible_values

is_possible <- function(possible_values) {
  # needs to be recursive:
  
  next_possible_values <- possible_values
  
  non_length_1 <- unlist(lapply(possible_values, FUN = function(x) length(x) > 1))
  if(sum(non_length_1) != 0) {
    first_non_length_1 <- names(non_length_1[non_length_1][1])
    
    next_possible_values[first_non_length_1] <- next_possible_values[[first_non_length_1]][1]
	return(letters_possible(next_possible_values))
  } else {
    for(i in 1:50) next_possible_values <- lapply(all_letters, reduced_possible_values, next_possible_values)
	if(any(lapply(next_possible_values, length) == 0)) return(FALSE)
    browser()
	if(!conforms_to_max_sums(next_possible_values)) {
	  remove_possibility(next_possible_values, "all_possible_values") 
	  return(FALSE)}
	return(TRUE)
  }
}

combination <- all_possible_values
test_all_possible_values <- list(a = 1, b = 1:2, c = 1:2)


# working_combination <- function(test_all_possible_values) {
#   next_possible_values <- test_all_possible_values
#   non_length_1 <- unlist(lapply(test_all_possible_values, FUN = function(x) length(x) > 1))
#   if(sum(non_length_1) > 1) {
#     first_non_length_1 <- names(non_length_1[non_length_1][1])
#     next_possible_values[first_non_length_1] <- next_possible_values[[first_non_length_1]][1]
# 	  if(working_combination(next_possible_values)) {
# 	    print(next_possible_values)
# 		return(next_possible_values)
# 	  } else {
# 		next_possible_values[first_non_length_1] <- test_all_possible_values[[first_non_length_1]][-1]
# 		return(working_combination(next_possible_values))
# 	  }
#   } else {
#     if(sum(non_length_1) == 1) {
# 	  first_non_length_1 <- names(non_length_1[non_length_1][1])
#       single_next_possible_values <- next_possible_values
#       single_next_possible_values[first_non_length_1] <- single_next_possible_values[[first_non_length_1]][1]
# 	
# 	  #if(conforms_to_max_sums(single_next_possible_values)) {
# 	  if(sum(unlist(single_next_possible_values)) == 5) {
# 	    print(single_next_possible_values)
# 	    return(single_next_possible_values)
# 	    #return(TRUE)
# 	  } else {
# 	    next_possible_values[[first_non_length_1]] <- next_possible_values[[first_non_length_1]][-1]
# 		return(working_combination(next_possible_values))
# 	  }
#     } else {
#       print(test_all_possible_values)
#       if(sum(unlist(test_all_possible_values)) == 5) {
#         return(test_all_possible_values)
#         #return(TRUE)
#       } else {
#         return(FALSE)
#       }
#   }}
# }
# a <- working_combination(test_all_possible_values)
library(compiler)
enableJIT(3)

working_combination <- function(test_all_possible_values) {
  print(unlist(test_all_possible_values))
  next_possible_values <- test_all_possible_values
  next_possible_values <- reduce_possibilities(next_possible_values)
  #non_length_1 <- unlist(lapply(test_all_possible_values, FUN = function(x) length(x) > 1))
  non_length_1 <- unlist(lapply(test_all_possible_values, length)) > 1
  message("\n\n", non_length_1, "\n")
  if(sum(non_length_1) > 1) {
    first_non_length_1 <- names(non_length_1[non_length_1][1])
    next_possible_values[[first_non_length_1]] <- next_possible_values[[first_non_length_1]][1]
	  if(isTRUE(working_combination(next_possible_values))) {
	    #print(next_possible_values)
		return(next_possible_values)
	  } else {
		next_possible_values[[first_non_length_1]] <- test_all_possible_values[[first_non_length_1]][-1]
		return(working_combination(next_possible_values))
	  }
  } else {
    if(sum(non_length_1) == 1) {
	  first_non_length_1 <- names(non_length_1[non_length_1][1])
      single_next_possible_values <- next_possible_values
      single_next_possible_values[[first_non_length_1]] <- single_next_possible_values[[first_non_length_1]][1]
	
	  #if(conforms_to_max_sums(single_next_possible_values)) {
	  if(isTRUE(working_single_combinations(single_next_possible_values))) {
	    #print(single_next_possible_values)
	    return(single_next_possible_values)
	    #return(TRUE)
	  } else {
	    next_possible_values[[first_non_length_1]] <- next_possible_values[[first_non_length_1]][-1]
		return(next_possible_values)
	  }
    } else {
      #print(test_all_possible_values)
      if(isTRUE(working_single_combinations(next_possible_values))) {
        return(test_all_possible_values)
        #return(TRUE)
      } else {
        return(FALSE)
      }
  }}
}
tst_all_possible_values <- all_possible_values
tst_all_possible_values[["a"]] <- 50

a <- working_combination(all_possible_values)
a <- working_combination(tst_all_possible_values)


system.time(replicate(10000, lapply(all_possible_values, length)))
system.time(replicate(10000, unlist(lapply(all_possible_values, length)) > 1))
system.time(replicate(10000, lapply(all_possible_values, length)))


working_single_combinations <- function(values) {
  return(
    {length(unique(unlist(values))) == length(unlist(values))}&&{
	conforms_to_max_sums(next_possible_values)})
}
